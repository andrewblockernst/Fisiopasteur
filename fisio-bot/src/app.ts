import { join } from 'path'
import { createBot, createProvider, createFlow, addKeyword, utils, EVENTS } from '@builderbot/bot'
import { MemoryDB as Database } from '@builderbot/bot'
import { BaileysProvider as Provider } from '@builderbot/provider-baileys'

const PORT = process.env.PORT ?? 3008

// Tipos para los datos del turno
interface TurnoData {
    pacienteNombre: string
    pacienteApellido: string
    telefono: string
    fecha: string
    hora: string
    profesional: string
    especialidad: string
    turnoId: string
    centroMedico?: string
}

// Flow de bienvenida general
const welcomeFlow = addKeyword<Provider, Database>(['hola', 'hi', 'hello', 'buenos dias', 'buenas tardes'])
    .addAnswer('üëã ¬°Hola! Soy el asistente virtual de *Fisiopasteur*')
    .addAnswer([
        'üè• Te ayudo con informaci√≥n sobre tus turnos de kinesiolog√≠a.',
        '',
        'Puedes escribir:',
        '‚Ä¢ *confirmar* - Para confirmar tu pr√≥ximo turno',
        '‚Ä¢ *cancelar* - Para cancelar un turno',
        '‚Ä¢ *info* - Para informaci√≥n del centro',
        '‚Ä¢ *ayuda* - Para ver todas las opciones'
    ].join('\n'))

// Flow para confirmaci√≥n de asistencia
const confirmarFlow = addKeyword<Provider, Database>(['confirmar', 'confirmo', 'si voy', 'asistir√©'])
    .addAnswer('‚úÖ ¬°Perfecto! He registrado tu confirmaci√≥n de asistencia.')
    .addAnswer([
        'üìã *Recordatorios importantes:*',
        '‚Ä¢ Llega 10 minutos antes de tu cita',
        '‚Ä¢ Trae ropa c√≥moda para la sesi√≥n',
        '‚Ä¢ Si necesitas cancelar, hazlo con 24hs de anticipaci√≥n'
    ].join('\n'))

// Flow para cancelaci√≥n
const cancelarFlow = addKeyword<Provider, Database>(['cancelar', 'no puedo ir', 'reprogramar'])
    .addAnswer('‚ùå Entiendo que necesitas cancelar tu turno.')
    .addAnswer(
        '¬øEst√°s seguro que deseas cancelar? Responde *SI* para confirmar o *NO* para mantener el turno.',
        { capture: true },
        async (ctx, { flowDynamic, state }) => {
            const response = ctx.body.toLowerCase()
            if (response.includes('si') || response.includes('s√≠')) {
                await flowDynamic('üóìÔ∏è Tu turno ha sido cancelado. Te enviaremos informaci√≥n para reprogramar pronto.')
                // Aqu√≠ se podr√≠a integrar con la API para cancelar el turno
            } else {
                await flowDynamic('üëç Perfecto, tu turno se mantiene confirmado.')
            }
        }
    )

// Flow de informaci√≥n del centro
const infoFlow = addKeyword<Provider, Database>(['info', 'informaci√≥n', 'direccion', 'horarios'])
    .addAnswer([
        'üè• *Informaci√≥n de Fisiopasteur*',
        '',
        'üìç **Direcci√≥n:** [Tu direcci√≥n aqu√≠]',
        'üìû **Tel√©fono:** [Tu tel√©fono aqu√≠]',
        'üïê **Horarios:** Lun a Vie 8:00 - 20:00, S√°b 8:00 - 14:00',
        '',
        'üöó **C√≥mo llegar:** [Instrucciones de ubicaci√≥n]'
    ].join('\n'))

// Flow de ayuda
const ayudaFlow = addKeyword<Provider, Database>(['ayuda', 'help', 'opciones', 'menu'])
    .addAnswer([
        'ü§ñ *Men√∫ de opciones:*',
        '',
        '‚Ä¢ *confirmar* - Confirmar asistencia a tu turno',
        '‚Ä¢ *cancelar* - Cancelar o reprogramar turno',
        '‚Ä¢ *info* - Informaci√≥n del centro m√©dico',
        '‚Ä¢ *contacto* - Hablar con recepci√≥n',
        '',
        'üí° Tambi√©n recibir√°s notificaciones autom√°ticas sobre tus turnos.'
    ].join('\n'))

// Flow para contacto directo
const contactoFlow = addKeyword<Provider, Database>(['contacto', 'recepcion', 'hablar', 'consulta'])
    .addAnswer([
        'üë• *Contacto directo:*',
        '',
        'üìû **Recepci√≥n:** [N√∫mero de tel√©fono]',
        'üìß **Email:** [Email del centro]',
        'üïê **Horarios de atenci√≥n:** Lun a Vie 8:00 - 20:00',
        '',
        'Tambi√©n puedes seguir escribiendo aqu√≠ y te ayudar√© en lo que necesites.'
    ].join('\n'))

// Flow para casos no entendidos
const fallbackFlow = addKeyword<Provider, Database>(utils.setEvent('FALLBACK'))
    .addAnswer([
        'ü§î No entend√≠ tu mensaje.',
        '',
        'Puedes escribir *ayuda* para ver las opciones disponibles',
        'o *contacto* para hablar directamente con recepci√≥n.'
    ].join('\n'))

// Funci√≥n auxiliar para formatear mensajes de turno
const formatearMensajeTurno = (turno: TurnoData, tipo: 'confirmacion' | 'recordatorio'): string => {
    const emoji = tipo === 'confirmacion' ? '‚úÖ' : '‚è∞'
    const titulo = tipo === 'confirmacion' ? 'Confirmaci√≥n de Turno' : 'Recordatorio de Turno'
    
    return [
        `${emoji} *${titulo}*`,
        '',
        `üë§ **Paciente:** ${turno.pacienteNombre} ${turno.pacienteApellido}`,
        `üìÖ **Fecha:** ${turno.fecha}`,
        `üïê **Hora:** ${turno.hora}`,
        `üë©‚Äç‚öïÔ∏è **Profesional:** ${turno.profesional}`,
        `üè• **Especialidad:** ${turno.especialidad}`,
        turno.centroMedico ? `üè¢ **Centro:** ${turno.centroMedico}` : '',
        '',
        tipo === 'confirmacion' ? 
            'Responde *confirmar* para confirmar tu asistencia o *cancelar* si no puedes asistir.' :
            '‚ö†Ô∏è Tu turno es en las pr√≥ximas horas. Responde *confirmar* si vas a asistir.',
        '',
        'üì± Para m√°s informaci√≥n escribe *info*'
    ].filter(line => line !== '').join('\n')
}

// Funci√≥n auxiliar para validar n√∫mero de tel√©fono
const formatearTelefono = (telefono: string): string => {
    console.log(`üì± Formateando tel√©fono: ${telefono}`)
    
    // Remover caracteres especiales y espacios
    const numero = telefono.replace(/[^0-9]/g, '')
    console.log(`üì± N√∫mero limpio: ${numero}`)
    
    let numeroFinal = numero
    
    // Si no tiene c√≥digo de pa√≠s, agregar Argentina (+54)
    if (!numero.startsWith('54') && numero.length === 10) {
        numeroFinal = `549${numero}`
    } else if (numero.startsWith('549') && numero.length === 13) {
        numeroFinal = numero
    } else if (numero.startsWith('54') && numero.length === 12) {
        numeroFinal = numero
    } else if (numero.length === 10) {
        numeroFinal = `549${numero}`
    }
    
    // Agregar @s.whatsapp.net al final
    const numeroFormateado = `${numeroFinal}@s.whatsapp.net`
    console.log(`üì± N√∫mero formateado final: ${numeroFormateado}`)
    
    return numeroFormateado
}

const main = async () => {
    // Configurar flows del bot
    const adapterFlow = createFlow([
        welcomeFlow,
        confirmarFlow,
        cancelarFlow,
        infoFlow,
        ayudaFlow,
        contactoFlow,
        fallbackFlow
    ])
    
    // Configuraci√≥n del provider para mostrar QR en logs de Heroku
    const adapterProvider = createProvider(Provider, {
        writeMyself: 'both'
    })
    const adapterDB = new Database()

    const { handleCtx, httpServer } = await createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
    })

    // Escuchar evento QR y mostrarlo en logs para Heroku
    adapterProvider.on('qr', (qr) => {
        console.log('üî•üî•üî• CODIGO QR PARA ESCANEAR üî•üî•üî•')
        console.log(qr)
        console.log('üî•üî•üî• ESCANEA ESTE CODIGO CON WHATSAPP üî•üî•üî•')
    })

    // ===== ENDPOINTS PARA INTEGRACI√ìN CON FISIOPASTEUR =====
    
    // Endpoint para confirmar turno (desde el sistema principal)
    adapterProvider.server.post(
        '/api/turno/confirmar',
        handleCtx(async (bot, req, res) => {
            try {
                // Verificar m√∫ltiples condiciones del bot
                if (!bot) {
                    res.writeHead(503, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Bot no inicializado',
                        code: 'BOT_NOT_READY'
                    }))
                }
                
                // Verificar si el bot est√° autenticado y listo
                const isAuthenticated = adapterProvider.vendor?.authState?.creds ? true : false
                // Simplificamos la verificaci√≥n de conexi√≥n
                const isReady = adapterProvider.vendor ? true : false
                
                if (!isAuthenticated) {
                    res.writeHead(503, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Bot no autenticado. Escanee el c√≥digo QR.',
                        code: 'NOT_AUTHENTICATED'
                    }))
                }
                
                if (!isReady) {
                    res.writeHead(503, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Bot no conectado a WhatsApp. Intente nuevamente en unos segundos.',
                        code: 'NOT_CONNECTED'
                    }))
                }
                
                const turnoData: any = req.body
                
                // Extraer datos con compatibilidad para ambas estructuras
                const telefono = turnoData.telefono
                const pacienteNombre = turnoData.pacienteNombre || turnoData.paciente?.nombre
                const pacienteApellido = turnoData.pacienteApellido || turnoData.paciente?.apellido
                const especialistaNombre = turnoData.profesional || turnoData.especialista?.nombre
                
                // Validar datos requeridos
                if (!telefono || !pacienteNombre) {
                    res.writeHead(400, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Datos incompletos. Tel√©fono y nombre son requeridos.',
                        code: 'INVALID_DATA',
                        received: { telefono, pacienteNombre, data: turnoData }
                    }))
                }
                
                // Crear objeto normalizado para el mensaje
                const datosNormalizados = {
                    ...turnoData,
                    pacienteNombre,
                    pacienteApellido,
                    profesional: especialistaNombre,
                    telefono
                }
                
                const numeroFormateado = formatearTelefono(telefono)
                const mensaje = formatearMensajeTurno(datosNormalizados, 'confirmacion')
                
                console.log(`üì§ Enviando mensaje a ${numeroFormateado}: ${mensaje.substring(0, 50)}...`)
                
                // Verificaci√≥n adicional de la sesi√≥n antes de enviar
                await new Promise(resolve => setTimeout(resolve, 1000)) // Esperar 1 segundo
                
                // Verificar que el vendor est√© correctamente inicializado
                if (!adapterProvider.vendor?.authState?.creds) {
                    throw new Error('Sesi√≥n de WhatsApp no inicializada completamente')
                }
                
                // Intentar enviar el mensaje con manejo de errores espec√≠fico
                try {
                    await bot.sendMessage(numeroFormateado, mensaje)
                    console.log(`‚úÖ Mensaje enviado exitosamente a ${numeroFormateado}`)
                } catch (sendError) {
                    console.error(`‚ùå Error espec√≠fico enviando mensaje:`, sendError)
                    // Intentar una vez m√°s despu√©s de un peque√±o delay
                    console.log(`üîÑ Reintentando env√≠o en 2 segundos...`)
                    await new Promise(resolve => setTimeout(resolve, 2000))
                    try {
                        await bot.sendMessage(numeroFormateado, mensaje)
                        console.log(`‚úÖ Mensaje enviado exitosamente en segundo intento a ${numeroFormateado}`)
                    } catch (retryError) {
                        console.error(`‚ùå Error en reintento:`, retryError)
                        throw new Error(`Error enviando mensaje: ${sendError instanceof Error ? sendError.message : 'Error desconocido'}`)
                    }
                }
                
                res.writeHead(200, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'success', 
                    message: 'Confirmaci√≥n enviada',
                    turnoId: turnoData.turnoId || turnoData.id_turno
                }))
            } catch (error) {
                console.error('Error enviando confirmaci√≥n:', error)
                res.writeHead(500, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'error', 
                    message: 'Error interno del servidor',
                    details: error instanceof Error ? error.message : 'Error desconocido'
                }))
            }
        })
    )
    
    // Endpoint para recordatorio de turno
    adapterProvider.server.post(
        '/api/turno/recordatorio',
        handleCtx(async (bot, req, res) => {
            try {
                // Verificar m√∫ltiples condiciones del bot
                if (!bot) {
                    res.writeHead(503, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Bot no inicializado',
                        code: 'BOT_NOT_READY'
                    }))
                }
                
                // Verificar si el bot est√° autenticado y listo
                const isAuthenticated = adapterProvider.vendor?.authState?.creds ? true : false
                const isReady = adapterProvider.vendor ? true : false
                
                if (!isAuthenticated) {
                    res.writeHead(503, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Bot no autenticado. Escanee el c√≥digo QR.',
                        code: 'NOT_AUTHENTICATED'
                    }))
                }
                
                if (!isReady) {
                    res.writeHead(503, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Bot no conectado a WhatsApp. Intente nuevamente en unos segundos.',
                        code: 'NOT_CONNECTED'
                    }))
                }
                
                const turnoData: any = req.body
                
                // Extraer datos con compatibilidad para ambas estructuras
                const telefono = turnoData.telefono
                const pacienteNombre = turnoData.pacienteNombre || turnoData.paciente?.nombre
                const pacienteApellido = turnoData.pacienteApellido || turnoData.paciente?.apellido
                const especialistaNombre = turnoData.profesional || turnoData.especialista?.nombre
                
                // Validar datos requeridos
                if (!telefono || !pacienteNombre) {
                    res.writeHead(400, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Datos incompletos. Tel√©fono y nombre son requeridos.',
                        code: 'INVALID_DATA'
                    }))
                }
                
                // Crear objeto normalizado para el mensaje
                const datosNormalizados = {
                    ...turnoData,
                    pacienteNombre,
                    pacienteApellido,
                    profesional: especialistaNombre,
                    telefono
                }
                
                const numeroFormateado = formatearTelefono(telefono)
                const mensaje = formatearMensajeTurno(datosNormalizados, 'recordatorio')
                
                console.log(`üì§ Enviando recordatorio a ${numeroFormateado}: ${mensaje.substring(0, 50)}...`)
                
                // Verificaci√≥n adicional de la sesi√≥n antes de enviar
                await new Promise(resolve => setTimeout(resolve, 1000)) // Esperar 1 segundo
                
                // Verificar que el vendor est√© correctamente inicializado
                if (!adapterProvider.vendor?.authState?.creds) {
                    throw new Error('Sesi√≥n de WhatsApp no inicializada completamente')
                }
                
                // Intentar enviar el mensaje con manejo de errores espec√≠fico
                try {
                    await bot.sendMessage(numeroFormateado, mensaje)
                    console.log(`‚úÖ Recordatorio enviado exitosamente a ${numeroFormateado}`)
                } catch (sendError) {
                    console.error(`‚ùå Error espec√≠fico enviando recordatorio:`, sendError)
                    // Intentar una vez m√°s despu√©s de un peque√±o delay
                    console.log(`üîÑ Reintentando env√≠o de recordatorio en 2 segundos...`)
                    await new Promise(resolve => setTimeout(resolve, 2000))
                    try {
                        await bot.sendMessage(numeroFormateado, mensaje)
                        console.log(`‚úÖ Recordatorio enviado exitosamente en segundo intento a ${numeroFormateado}`)
                    } catch (retryError) {
                        console.error(`‚ùå Error en reintento de recordatorio:`, retryError)
                        throw new Error(`Error enviando recordatorio: ${sendError instanceof Error ? sendError.message : 'Error desconocido'}`)
                    }
                }
                
                res.writeHead(200, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'success', 
                    message: 'Recordatorio enviado',
                    turnoId: turnoData.turnoId
                }))
            } catch (error) {
                console.error('Error enviando recordatorio:', error)
                res.writeHead(500, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'error', 
                    message: 'Error interno del servidor',
                    details: error instanceof Error ? error.message : 'Error desconocido'
                }))
            }
        })
    )
    
    // Endpoint gen√©rico para enviar mensajes
    adapterProvider.server.post(
        '/api/mensaje/enviar',
        handleCtx(async (bot, req, res) => {
            try {
                const { telefono, mensaje, media } = req.body
                
                if (!telefono || !mensaje) {
                    res.writeHead(400, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Tel√©fono y mensaje son requeridos'
                    }))
                }
                
                if (!bot) {
                    throw new Error('Bot no inicializado')
                }
                
                const numeroFormateado = formatearTelefono(telefono)
                await bot.sendMessage(numeroFormateado, mensaje, { media: media ?? null })
                
                res.writeHead(200, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'success', 
                    message: 'Mensaje enviado correctamente'
                }))
            } catch (error) {
                console.error('Error enviando mensaje:', error)
                res.writeHead(500, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'error', 
                    message: 'Error interno del servidor'
                }))
            }
        })
    )
    
    // Endpoint para gesti√≥n de lista negra
    adapterProvider.server.post(
        '/api/blacklist',
        handleCtx(async (bot, req, res) => {
            try {
                const { telefono, accion } = req.body
                const numeroFormateado = formatearTelefono(telefono)
                
                if (!bot) {
                    throw new Error('Bot no inicializado')
                }
                
                if (accion === 'remover') {
                    bot.blacklist.remove(numeroFormateado)
                } else if (accion === 'agregar') {
                    bot.blacklist.add(numeroFormateado)
                } else {
                    res.writeHead(400, { 'Content-Type': 'application/json' })
                    return res.end(JSON.stringify({ 
                        status: 'error', 
                        message: 'Acci√≥n debe ser "agregar" o "remover"'
                    }))
                }
                
                res.writeHead(200, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'success', 
                    telefono: numeroFormateado, 
                    accion 
                }))
            } catch (error) {
                console.error('Error gestionando blacklist:', error)
                res.writeHead(500, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'error', 
                    message: 'Error interno del servidor'
                }))
            }
        })
    )
    
    // Endpoint temporal para restaurar sesi√≥n de WhatsApp
    adapterProvider.server.get('/api/restore-session', async (req, res) => {
        try {
            const { execSync } = await import('child_process')
            const { existsSync } = await import('fs')
            const { join } = await import('path')
            const { fileURLToPath } = await import('url')
            
            // Obtener __dirname equivalente para m√≥dulos ES
            const __filename = fileURLToPath(import.meta.url)
            const __dirname = join(__filename, '..')
            
            // Verificar si existe el archivo de sesi√≥n
            const sessionFile = join(__dirname, 'whatsapp_session.tar.gz')
            if (existsSync(sessionFile)) {
                // Extraer la sesi√≥n
                execSync(`cd ${__dirname} && tar -xzf whatsapp_session.tar.gz`)
                
                res.writeHead(200, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'success',
                    message: 'Sesi√≥n de WhatsApp restaurada. Reiniciando bot...'
                }))
            } else {
                res.writeHead(404, { 'Content-Type': 'application/json' })
                return res.end(JSON.stringify({ 
                    status: 'error',
                    message: 'Archivo de sesi√≥n no encontrado'
                }))
            }
        } catch (error) {
            console.error('Error restaurando sesi√≥n:', error)
            res.writeHead(500, { 'Content-Type': 'application/json' })
            return res.end(JSON.stringify({ 
                status: 'error',
                message: 'Error restaurando sesi√≥n'
            }))
        }
    })

    // Endpoint de estado/health check
    adapterProvider.server.get('/api/health', (req, res) => {
        res.writeHead(200, { 'Content-Type': 'application/json' })
        return res.end(JSON.stringify({ 
            status: 'ok',
            timestamp: new Date().toISOString(),
            service: 'Fisiopasteur WhatsApp Bot'
        }))
    })
    
    // Endpoint para verificar si est√° autenticado
    adapterProvider.server.get('/api/status', (req, res) => {
        const isAuthenticated = adapterProvider.vendor?.authState?.creds ? true : false
        res.writeHead(200, { 'Content-Type': 'application/json' })
        return res.end(JSON.stringify({ 
            authenticated: isAuthenticated,
            timestamp: new Date().toISOString(),
            service: 'Fisiopasteur WhatsApp Bot'
        }))
    })

    console.log(`ü§ñ Bot de Fisiopasteur iniciado en puerto ${PORT}`)
    console.log(`üì± Endpoints disponibles:`)
    console.log(`   POST /api/turno/confirmar - Enviar confirmaci√≥n de turno`)
    console.log(`   POST /api/turno/recordatorio - Enviar recordatorio`)
    console.log(`   POST /api/mensaje/enviar - Enviar mensaje gen√©rico`)
    console.log(`   POST /api/blacklist - Gestionar lista negra`)
    console.log(`   GET /api/health - Estado del servicio`)
    
    httpServer(+PORT)
}

main().catch(console.error)
